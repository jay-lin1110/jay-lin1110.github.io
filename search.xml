<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue框架的简单实现</title>
      <link href="/2020/01/28/vue2-mvvm/"/>
      <url>/2020/01/28/vue2-mvvm/</url>
      
        <content type="html"><![CDATA[<p>自定义封装实现 vue2 框架，实现 MVVM 功能，包括模板编译、指令解析和数据（双向）绑定的功能。</p><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>MVVM 分别指 View，Model，View-Model，View 通过 View-Model 的 DOM Listeners 将事件绑定到 Model 上，而 Model 则通过 Data Bindings 来管理 View 中的数据，View-Model 从中起到一个连接桥的作用。</p><p>在 MVVM 中 View 和 Model 是不可以直接进行通信的，它们之间存在这 ViewModel 这个中介充当着观察者的角色。当用户操作 View，ViewModel 感知到变化，然后通知 Model 发生相应改变，反之亦然。ViewModel 向上与视图层 View 进行双向数据绑定，向下与 Model 通过接口请求进行数据交互，起到承上启下的作用。</p><p><img src="/img/mvvm.jpg" alt=""></p><h2 id="概念详解"><a href="#概念详解" class="headerlink" title="概念详解"></a>概念详解</h2><ul><li>M——Model 层（数据模型 | 状态）</li></ul><p>数据模型与持久化抽象模型。数据模型很好理解，就是从服务器拉回来的 JSON 数据。而持久化抽象模型暂时放在 Model 层，是因为 MVVM 诞生之初就没有对这块进行很细致的描述。按照经验，我们通常把数据库、文件操作封装成 Model，并对外提供操作接口。</p><ul><li>V——View 层（视图层）</li></ul><p>视图展示。包含 UIView 以及 UIViewController，View 层是可以持有 ViewModel 的。</p><ul><li>VM——ViewModel（视图适配）</li></ul><p>视图适配器。暴露属性与 View 元素显示内容或者元素状态一一对应。一般情况下 ViewModel 暴露的属性建议是 readOnly 的，至于为什么，我们在实战中会去解释。还有一点，ViewModel 层是可以持有 Model 的。ViewModel 类似中转站(Value Converter)，负责转换 Model 中的数据对象，使得数据变得更加易于管理和使用。MVVM 本质就是基于操作数据来操作视图进而操作 DOM，借助于 MVVM 无需直接操作 DOM，开发者只需完成包含声明绑定的视图模板，编写 ViewModel 中有业务，使得 View 完全实现自动化。</p><h2 id="与-MVC-区别"><a href="#与-MVC-区别" class="headerlink" title="与 MVC 区别"></a>与 MVC 区别</h2><ol><li>实现了<strong>数据</strong>与<strong>视图</strong>的分离</li><li>解耦了 DOM 操作</li></ol><p>通过<strong>数据</strong>来驱动<strong>视图</strong>，开发者只需要关心数据变化，DOM 操作被封装了。</p><h2 id="实现原理-（功能）"><a href="#实现原理-（功能）" class="headerlink" title="实现原理 （功能）"></a>实现原理 （功能）</h2><ul><li>响应式数据</li></ul><p>监听 data 属性的变化，在 vue 中，依赖于 ES5 的一个方法——<code>Object.defineProperty ()</code>来实现<strong>数据劫持</strong></p><ul><li>模板编译</li></ul><p>这里主要实现了一般指令、事件指令和插值表达式的编译解析</p><ul><li>观察者模式</li></ul><p>使用了发布-订阅模式来实现数据驱动视图和数据（双向）绑定</p><p><img src="/img/vue-mvvm.jpg" alt=""></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>自定义封装实现<a href="https://gitee.com/jaylin1011/vue2-mvvm" target="_blank" rel="noopener">Vue2</a>框架，实现 MVVM 功能，包括模板编译、指令解析和数据（双向）绑定的功能。</p><h3 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h3><p>Vue2 类是核心类之一，主要实现了 MVVM 初始化和数据代理的功能</p><pre><code>class Vue2 {  constructor(options) {    const { el, data, computed, methods } = options    this.$el = el    this.$data = data    if (this.$el) {      new Observer(this.$data)      this.compileComputed(this.$data, computed)      this.compileMethods(methods)      // 数据代理vm.$data.xxx =&gt; vm.xxx      this._proxy(this.$data)      new Compile(this.$el, this)    }  }  compileComputed(data, computed) {    Object.keys(computed).forEach(key =&gt; {      Object.defineProperty(data, key, {        get: () =&gt; computed[key].call(this)      })    })  }  compileMethods(methods) {    Object.keys(methods).forEach(key =&gt; {      Object.defineProperty(this, key, {        get: () =&gt; methods[key]      })    })  }  _proxy(data) {    Object.keys(data).forEach(key =&gt; {      Object.defineProperty(this, key, {        get() {          return data[key]        },        set(newValue) {          data[key] = newValue        }      })    })  }}</code></pre><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p>Complile 类是核心类之一，将当前页面的所有元素节点碎片化放入内存中，编译元素节点和文本节点，解析各种相关指令，将编译完成的文档碎片从内存中取出放回页面</p><pre><code>class Compile {  constructor(el, vm) {    this.el = this.isElementNode(el) ? el : document.querySelector(el)    this.vm = vm    const fragment = this.nodeToFragment(this.el)    this.compile(fragment)    this.el.appendChild(fragment)  }  isElementNode(node) {    return node.nodeType === 1  }  isTextNode(node) {    return node.nodeType === 3  }  isDirective(attrName) {    return attrName.startsWith(&#39;v-&#39;)  }  isEventDirective(attrName) {    return attrName.startsWith(&#39;@&#39;)  }  isMustache(content) {    // return content.includes(&#39;{{&#39;)    const reg = /\{\{(.+?)\}\}/    return reg.test(content)  }  nodeToFragment(node) {    const fragment = document.createDocumentFragment()    let firstChild    // eslint-disable-next-line no-cond-assign    while (firstChild = node.firstChild) {      fragment.appendChild(firstChild)    }    return fragment  }  compile(fragment) {    // 当前模板的第一层子节点    const childNodes = fragment.childNodes;    [...childNodes].forEach(child =&gt; {      if (this.isElementNode(child)) {        this.compileElement(child)        if (child.childNodes &amp;&amp; child.childNodes.length) {          this.compile(child)        }      } else {        this.compileText(child)      }    })  }  compileElement(node) {    const attributes = node.attributes;    [...attributes].forEach(attr =&gt; {      // 根据属性获取属性名和属性值      // v-model = &#39;daisy.name&#39; =&gt; {name: &#39;v-model&#39;, value: &#39;daisy.name&#39;      const { name, value: exp } = attr      if (this.isDirective(name)) {        // 根据属性名字截取指令名字        // v-model =&gt; [&#39;v&#39;, &#39;model&#39;]        const [, directive] = name.split(&#39;-&#39;)        // 根据指令名字截取事件名字        // on:click =&gt; [&#39;on&#39;, &#39;click&#39;]        const [directiveName, eventName] = directive.split(&#39;:&#39;)        CompileUtils[directiveName](node, exp, this.vm, eventName)        // 指令编译完成后删除标签的指令属性        node.removeAttribute(`v-${directive}`)      } else if (this.isEventDirective(name)) {        const [, eventName] = name.split(&#39;@&#39;)        CompileUtils[&#39;on&#39;](node, exp, this.vm, eventName)      }    })  }  compileText(node) {    const content = node.textContent    if (this.isMustache(content)) {      CompileUtils[&#39;mustache&#39;](node, content, this.vm)    }  }}</code></pre><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer 类是核心类之一，通过递归的方式和<code>Object.defineProperty ()</code>方法将数据响应式化，实现数据的深层劫持，监听数据的属性（此处并没有通过函数拦截的方式数组类型数据进行额外的处理）</p><pre><code>class Observer {  constructor(data) {    this.observer(data)  }  isObject(value) {    return !!value &amp;&amp; typeof value === &#39;object&#39;  }  observer(data) {    if (this.isObject(data)) {      Object.keys(data).forEach(key =&gt; this.defineReactive(data, key, data[key]))    }  }  defineReactive(target, key, value) {    // 递归劫持嵌套对象    this.observer(value)    const dep = new Dep()    Object.defineProperty(target, key, {      enumerable: true,      configurable: false,      get() {        Dep.target &amp;&amp; dep.addSub(Dep.target)        return value      },      set: (newValue) =&gt; {        if (newValue !== value) {          value = newValue          // 赋值为新对象，继续递归劫持          this.observer(value)          dep.notify()        }      }    })  }}</code></pre><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>Watcher 类进行依赖收集</p><pre><code>class Watcher {  constructor(vm, exp, cb) {    this.vm = vm    this.exp = exp    this.cb = cb    // 存放老值    this.oldValue = this.getOldValue()  }  getOldValue() {    Dep.target = this    const value = CompileUtils.getValue(this.vm, this.exp)    Dep.target = null    return value  }  update() {    const newValue = CompileUtils.getValue(this.vm, this.exp)    if (newValue !== this.oldValue) {      this.cb(newValue)    }  }}</code></pre><p>Dep</p><p>Dep 类当数据更新时进行派发更新</p><pre><code>class Dep {  constructor() {    // 存放所有watcher    this.subs = []  }  // 订阅，添加watcher  addSub(watcher) {    this.subs.push(watcher)  }  // 发布  notify() {    this.subs.forEach(watcher =&gt; watcher.update())  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是一条用于测试的肠粉</title>
      <link href="/2018/06/27/hello-world/"/>
      <url>/2018/06/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是一条神奇的肠粉，因为它具有特别的纪念意义。<br>一来这是纪念本人和小铭同学一起吃过的正宗早餐。<br>二来这是本博客测试的第一条肠粉。</p><h2 id="肠粉的故事"><a href="#肠粉的故事" class="headerlink" title="肠粉的故事"></a>肠粉的故事</h2><p><img src="/img/boys.jpeg" alt=""><br>话说那是一个阳光灿烂的早晨。<br>男孩们约好一起恰早餐。<br>正苦恼吃啥玩意的时候。<br>一阵风带来了米浆的清香。<br>Boys 当机立断，决定选择肠粉。</p><h2 id="肠粉起源"><a href="#肠粉起源" class="headerlink" title="肠粉起源"></a>肠粉起源</h2><p>肠粉按地理（口味）区分较出名的有广州的西关肠粉，普宁肠粉，揭阳小巷里的潮汕肠粉、潮州潮汕肠粉，云浮的河口肠粉，梅州的客家肠粉，郁南的都城肠粉、澄海肠粉、饶平肠粉、惠来肠粉等。<br>广州的肠粉呈现透明状，口感比较 q 弹，一般酱料是酱油及其他酱制成，口感较甜，配菜多为生菜。潮州的肠粉呈现白色，口感香糯，酱料多为耗油花生酱，配菜各式各样。<br>潮汕肠粉各地有各地特色，比如汕头市澄海区的肠粉，酱汁比较多，酱汁的味道也比较淡，里面最常见菜是豆芽，生菜，而且还有肉末香菇鲜虾等。普宁的潮汕肠粉常见的是生蚝，香菇，白萝卜干干鱿鱼，鸡蛋，生菜，西洋菜，空心菜，肉沫，鲍鱼等。</p>]]></content>
      
      
      <categories>
          
          <category> Food </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Food </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Promises/A+规范封装Promise</title>
      <link href="/2018/06/27/promises-aplus/"/>
      <url>/2018/06/27/promises-aplus/</url>
      
        <content type="html"><![CDATA[<p>基于 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+规范</a>规范自定义封装一个 <a href="https://github.com/jaylin1011/promises-aplus" target="_blank" rel="noopener">PromiseA 类</a>，实现 ECMAScript2015 中 <code>Promise</code> 的基本功能，<a href="https://gitee.com/jaylin1011/promises-aplus" target="_blank" rel="noopener">PromiseA 类</a>实现核心<code>then</code>方法，同时包括实例方法<code>catch</code>和静态方法<code>all</code>,<code>race</code>，<code>resolve</code>,<code>reject</code>等。</p><h1 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises/A+"></a>Promises/A+</h1><p><img src="/img/callback-hell.jpg" alt=""><br><code>Promise</code> 表示一个异步操作的最终结果，与之进行交互的方式主要是 <code>then</code> 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。</p><p>本规范详细列出了 <code>then</code> 方法的执行过程，所有遵循 Promises/A+ 规范实现的 promise 均可以本标准作为参照基础来实施 <code>then</code> 方法。因而本规范是十分稳定的。尽管 Promise/A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。</p><p>从历史上说，本规范实际上是把之前 Promise/A+ 规范中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。</p><p>最后，核心的 Promises/A+ 规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 <code>then</code> 方法。上述对于 promises 的操作方法将来在其他规范中可能会提及。</p><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>promise 是一个拥有 <code>then</code> 方法的对象或函数，其行为符合本规范；</p><h2 id="thenable"><a href="#thenable" class="headerlink" title="thenable"></a>thenable</h2><p>是一个定义了 <code>then</code> 方法的对象或函数，文中译作“拥有 <code>then</code> 方法”；</p><h2 id="值（value）"><a href="#值（value）" class="headerlink" title="值（value）"></a>值（value）</h2><p>指任何 JavaScript 的合法值（包括 <code>undefined</code> , thenable 和 promise）；</p><h2 id="异常（exception）"><a href="#异常（exception）" class="headerlink" title="异常（exception）"></a>异常（exception）</h2><p>是使用 <code>throw</code> 语句抛出的一个值。</p><h2 id="据因（reason）"><a href="#据因（reason）" class="headerlink" title="据因（reason）"></a>据因（reason）</h2><p>表示一个 promise 的拒绝原因。</p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><hr><h2 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h2><p>一个 Promise 的当前状态必须为以下三种状态中的一种：<strong>等待态（Pending）</strong>、<strong>执行态（Fulfilled）</strong>和<strong>拒绝态（Rejected）</strong>。</p><h3 id="等待态（Pending）"><a href="#等待态（Pending）" class="headerlink" title="等待态（Pending）"></a>等待态（Pending）</h3><p>处于等待态时，promise 需满足以下条件：</p><ul><li>可以迁移至执行态或拒绝态</li></ul><h3 id="执行态（Fulfilled）"><a href="#执行态（Fulfilled）" class="headerlink" title="执行态（Fulfilled）"></a>执行态（Fulfilled）</h3><p>处于执行态时，promise 需满足以下条件：</p><ul><li>不能迁移至其他任何状态</li><li>必须拥有一个<strong>不可变</strong>的终值</li></ul><h3 id="拒绝态（Rejected）"><a href="#拒绝态（Rejected）" class="headerlink" title="拒绝态（Rejected）"></a>拒绝态（Rejected）</h3><p>处于拒绝态时，promise 需满足以下条件：</p><ul><li>不能迁移至其他任何状态</li><li>必须拥有一个<strong>不可变</strong>的据因</li></ul><p>这里的不可变指的是恒等（即可用 <code>===</code> 判断相等），而不是意味着更深层次的不可变（<strong>译者注：</strong>盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// states</span><span class="token keyword">const</span> FULFILLED <span class="token operator">=</span> <span class="token string">"fulfilled"</span><span class="token punctuation">;</span><span class="token keyword">const</span> REJECTED <span class="token operator">=</span> <span class="token string">"rejected"</span><span class="token punctuation">;</span><span class="token keyword">const</span> PENDING <span class="token operator">=</span> <span class="token string">"pending"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// init state and value</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> PENDING<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> undefined<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// define resolve function</span><span class="token keyword">const</span> resolve <span class="token operator">=</span> value <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">PromiseA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> FULFILLED<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>callbackObj <span class="token operator">=</span><span class="token operator">></span> callbackObj<span class="token punctuation">.</span><span class="token function">onFulfilled</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// define reject function</span><span class="token keyword">const</span> reject <span class="token operator">=</span> reason <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> REJECTED<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> reason<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>callbackObj <span class="token operator">=</span><span class="token operator">></span> callbackObj<span class="token punctuation">.</span><span class="token function">onRejected</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Then-方法"><a href="#Then-方法" class="headerlink" title="Then 方法"></a><strong>Then 方法</strong></h2><p>一个 promise 必须提供一个 <code>then</code> 方法以访问其当前值、终值和据因。</p><p>promise 的 <code>then</code> 方法接受两个参数：</p><pre><code>promise.then(onFulfilled, onRejected)</code></pre><h3 id="参数可选"><a href="#参数可选" class="headerlink" title="参数可选"></a>参数可选</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数。</p><ul><li>如果 <code>onFulfilled</code> 不是函数，其必须被忽略</li><li>如果 <code>onRejected</code> 不是函数，其必须被忽略</li></ul><h3 id="onFulfilled-特性"><a href="#onFulfilled-特性" class="headerlink" title="onFulfilled 特性"></a><code>onFulfilled</code> 特性</h3><p>如果 <code>onFulfilled</code> 是函数：</p><ul><li>当 <code>promise</code> 执行结束后其必须被调用，其第一个参数为 <code>promise</code> 的终值</li><li>在 <code>promise</code> 执行结束前其不可被调用</li><li>其调用次数不可超过一次</li></ul><h3 id="onRejected-特性"><a href="#onRejected-特性" class="headerlink" title="onRejected 特性"></a><code>onRejected</code> 特性</h3><p>如果 <code>onRejected</code> 是函数：</p><ul><li>当 <code>promise</code> 被拒绝执行后其必须被调用，其第一个参数为 <code>promise</code> 的据因</li><li>在 <code>promise</code> 被拒绝执行前其不可被调用</li><li>其调用次数不可超过一次</li></ul><h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a href="http://es5.github.io/#x10.3" target="_blank" rel="noopener">执行环境</a>堆栈仅包含<strong>平台代码</strong>时才可被调用</p><h3 id="调用要求"><a href="#调用要求" class="headerlink" title="调用要求"></a>调用要求</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值）</p><h3 id="多次调用"><a href="#多次调用" class="headerlink" title="多次调用"></a>多次调用</h3><p><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</p><ul><li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li><li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其注册顺序依次回调</li></ul><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p><code>then</code> 方法必须返回一个 <code>promise</code> 对象</p><pre><code>promise2 = promise1.then(onFulfilled, onRejected);</code></pre><ul><li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></li><li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></li><li>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</li><li>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的据因</li></ul><p><strong>译者注：</strong>理解上面的“返回”部分非常重要，即：<strong>不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve，只有出现异常时才会被 rejected</strong>。</p><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 2.2.1 Both onFulfilled and onRejected are optional arguments</span>    onFulfilled <span class="token operator">=</span> <span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onFulfilled <span class="token punctuation">:</span> value <span class="token operator">=</span><span class="token operator">></span> value    onRejected <span class="token operator">=</span> <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onRejected <span class="token punctuation">:</span> error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> error <span class="token punctuation">}</span>    <span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromiseA</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// handle sync tasks</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> FULFILLED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> REJECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// handle async tasks</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          onFulfilled<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// use async macro task to get promise2</span>              <span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// can't handle exception in async tasks outside,so handle it inside</span>                <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>                <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>              <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          onRejected<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// use async macro task to get promise2</span>              <span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// can't handle exception in async tasks outside,so handle it inside</span>                <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>                <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>              <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> promise2  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Promise-解决过程"><a href="#Promise-解决过程" class="headerlink" title="Promise 解决过程"></a><strong>Promise 解决过程</strong></h2><p><strong>Promise 解决过程</strong>是一个抽象的操作，其需输入一个 <code>promise</code> 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code> 。</p><p>这种 <em>thenable</em> 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 <code>then</code> 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p><p>运行 <code>[[Resolve]](promise, x)</code> 需遵循以下步骤：</p><h3 id="x-与-promise-相等"><a href="#x-与-promise-相等" class="headerlink" title="x 与 promise 相等"></a><code>x</code> 与 <code>promise</code> 相等</h3><p>如果 <code>promise</code> 和 <code>x</code> 指向同一对象，以 <code>TypeError</code> 为据因拒绝执行 <code>promise</code></p><h3 id="x-为-Promise"><a href="#x-为-Promise" class="headerlink" title="x 为 Promise"></a><code>x</code> 为 Promise</h3><p>如果 <code>x</code> 为 Promise ，则使 <code>promise</code> 接受 <code>x</code> 的状态 注 4：</p><ul><li>如果 <code>x</code> 处于等待态， <code>promise</code> 需保持为等待态直至 <code>x</code> 被执行或拒绝</li><li>如果 <code>x</code> 处于执行态，用相同的值执行 <code>promise</code></li><li>如果 <code>x</code> 处于拒绝态，用相同的据因拒绝 <code>promise</code></li></ul><h3 id="x-为对象或函数"><a href="#x-为对象或函数" class="headerlink" title="x 为对象或函数"></a><code>x</code> 为对象或函数</h3><p>如果 <code>x</code> 为对象或者函数：</p><ul><li>把 <code>x.then</code> 赋值给 <code>then</code> 注 5</li><li>如果取 <code>x.then</code> 的值时抛出错误 <code>e</code> ，则以 <code>e</code> 为据因拒绝 <code>promise</code></li><li>如果 <code>then</code> 是函数，将 <code>x</code> 作为函数的作用域 <code>this</code> 调用之。传递两个回调函数作为参数，第一个参数叫做 <code>resolvePromise</code> ，第二个参数叫做 <code>rejectPromise</code></li></ul><p>如果  <code>x</code>  不为对象或者函数，以  <code>x</code>  为参数执行  <code>promise</code></p><p>如果一个 promise 被一个循环的  <em>thenable</em>  链中的对象解决，而  <code>[[Resolve]](promise, thenable)</code>  的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的  <code>TypeError</code>  为据因来拒绝  <code>promise</code></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// promise resolution procedure</span><span class="token keyword">const</span> resolvePromise <span class="token operator">=</span> <span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 2.3.1 promise2 === x => TypeError</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Chaining cycle detected for promise #&lt;Promise>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// x是promise</span>    <span class="token keyword">let</span> isCalled<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2.3.3.3</span>        then<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>          x<span class="token punctuation">,</span>          y <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 2.3.3.3.1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isCalled<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            isCalled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          r <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 2.3.3.3.2</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isCalled<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            isCalled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2.3.3.4 x是对象</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 2.3.3.2 x.then出错</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>isCalled<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>      isCalled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 2.3.4 x不是promise</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ES2015 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES2015 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
